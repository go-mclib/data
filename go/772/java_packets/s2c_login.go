package packets

import (
	jp "github.com/go-mclib/protocol/java_protocol"
	ns "github.com/go-mclib/protocol/net_structures"
)

// S2CLoginDisconnectLogin represents "Disconnect (login)".
//
// https://minecraft.wiki/w/Java_Edition_protocol/Packets#Disconnect_(Login)
var S2CLoginDisconnectLogin = jp.NewPacket(jp.StateLogin, jp.S2C, 0x00)

type S2CLoginDisconnectLoginData struct {
	// The reason why the player was disconnected.
	Reason ns.JSONTextComponent
}

// S2CHello represents "Encryption Request".
//
// > See protocol encryption for details.
//
// https://minecraft.wiki/w/Java_Edition_protocol/Packets#Encryption_Request
var S2CHello = jp.NewPacket(jp.StateLogin, jp.S2C, 0x01)

type S2CHelloData struct {
	// Always empty when sent by the vanilla server.
	ServerId ns.String
	// The server's public key, in bytes.
	PublicKey ns.PrefixedByteArray
	// A sequence of random bytes generated by the server.
	VerifyToken ns.PrefixedByteArray
	// Whether the client should attempt to authenticate through mojang servers .
	ShouldAuthenticate ns.Boolean
}

// S2CLoginFinished represents "Login Success".
//
// > The Property field looks like response of Mojang API#UUID to Profile and Skin/Cape , except using the protocol format instead of JSON. That is, each player will usually have one property with Name being “textures” and Value being a base64-encoded JSON string, as documented at Mojang API#UUID to Profile and Skin/Cape . An empty properties array is also acceptable, and will cause clients to display the player with one of the two default skins depending their UUID (again, see the Mojang API page).
//
// https://minecraft.wiki/w/Java_Edition_protocol/Packets#Login_Success
var S2CLoginFinished = jp.NewPacket(jp.StateLogin, jp.S2C, 0x02)

type S2CLoginFinishedData struct {
	//
	Uuid ns.UUID
	//
	Username ns.String
	//
	Value ns.String
	//
	Signature ns.PrefixedOptional[ns.String]
}

// S2CLoginCompression represents "Set Compression".
//
// > Enables compression. If compression is enabled, all following packets are encoded in the compressed packet format . Negative values will disable compression, meaning the packet
// > format should remain in the uncompressed packet format . However, this packet is entirely optional, and if not sent, compression will also not be enabled (the vanilla server does
// > not send the packet when compression is disabled).
//
// https://minecraft.wiki/w/Java_Edition_protocol/Packets#Set_Compression
var S2CLoginCompression = jp.NewPacket(jp.StateLogin, jp.S2C, 0x03)

type S2CLoginCompressionData struct {
	// Maximum size of a packet before it is compressed.
	Threshold ns.VarInt
}

// S2CCustomQuery represents "Login Plugin Request".
//
// > Used to implement a custom handshaking flow together with Login Plugin Response .
// >
// > Unlike plugin messages in "play" mode, these messages follow a lock-step request/response scheme, where the client is expected to respond to a request indicating whether it understood. The vanilla client always
// > responds that it hasn't understood, and sends an empty payload.
//
// https://minecraft.wiki/w/Java_Edition_protocol/Packets#Login_Plugin_Request
var S2CCustomQuery = jp.NewPacket(jp.StateLogin, jp.S2C, 0x04)

type S2CCustomQueryData struct {
	// Generated by the server - should be unique to the connection.
	MessageId ns.VarInt
	// Name of the plugin channel used to send the data.
	Channel ns.Identifier
	// Any data, depending on the channel. The length of this array must be inferred from the packet length.
	Data ns.ByteArray
}

// S2CCookieRequestLogin represents "Cookie Request (login)".
//
// > Requests a cookie that was previously stored.
//
// https://minecraft.wiki/w/Java_Edition_protocol/Packets#Cookie_Request_(Login)
var S2CCookieRequestLogin = jp.NewPacket(jp.StateLogin, jp.S2C, 0x05)

type S2CCookieRequestLoginData struct {
	// The identifier of the cookie.
	Key ns.Identifier
}
