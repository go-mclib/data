package packets

import (
	jp "github.com/go-mclib/protocol/java_protocol"
	ns "github.com/go-mclib/protocol/net_structures"
)

// S2CLoginDisconnectLogin represents "Disconnect (login)".
//
// https://minecraft.wiki/w/Java_Edition_protocol/Packets#Disconnect_(Login)
var S2CLoginDisconnectLogin = jp.NewPacket(jp.StateLogin, jp.S2C, 0x00)

type S2CLoginDisconnectLoginData struct {
	// The reason why the player was disconnected.
	Reason ns.JSONTextComponent
}

// S2CHello represents "Encryption Request".
//
// > See protocol encryption for details.
//
// https://minecraft.wiki/w/Java_Edition_protocol/Packets#Encryption_Request
var S2CHello = jp.NewPacket(jp.StateLogin, jp.S2C, 0x01)

type S2CHelloData struct {
	// Always empty when sent by the vanilla server.
	ServerId ns.String
	// The server's public key, in bytes.
	PublicKey ns.PrefixedArray[ns.Byte]
	// A sequence of random bytes generated by the server.
	VerifyToken ns.PrefixedArray[ns.Byte]
	// Whether the client should attempt to authenticate through mojang servers .
	ShouldAuthenticate ns.Boolean
}

// S2CLoginFinished represents "Login Success".
//
// https://minecraft.wiki/w/Java_Edition_protocol/Packets#Login_Success
var S2CLoginFinished = jp.NewPacket(jp.StateLogin, jp.S2C, 0x02)

type S2CLoginFinishedData struct {
	//
	Profile ns.GameProfile
}

// S2CLoginCompression represents "Set Compression".
//
// > Enables compression. If compression is enabled, all following packets are encoded in the compressed packet format . Negative values will disable compression, meaning the packet format should remain in the uncompressed packet format . However, this packet is entirely optional, and if not sent, compression will also not be enabled (the vanilla server does not send the packet when compression is disabled).
//
// https://minecraft.wiki/w/Java_Edition_protocol/Packets#Set_Compression
var S2CLoginCompression = jp.NewPacket(jp.StateLogin, jp.S2C, 0x03)

type S2CLoginCompressionData struct {
	// Maximum size of a packet before it is compressed.
	Threshold ns.VarInt
}

// S2CCustomQuery represents "Login Plugin Request".
//
// > Used to implement a custom handshaking flow together with Login Plugin Response .
// >
// > Unlike plugin messages in "play" mode, these messages follow a lock-step request/response scheme, where the client is expected to respond to a request indicating whether it understood. The vanilla client always responds that it hasn't understood and sends an empty payload.
//
// https://minecraft.wiki/w/Java_Edition_protocol/Packets#Login_Plugin_Request
var S2CCustomQuery = jp.NewPacket(jp.StateLogin, jp.S2C, 0x04)

type S2CCustomQueryData struct {
	// Generated by the server - should be unique to the connection.
	MessageId ns.VarInt
	// Name of the plugin channel used to send the data.
	Channel ns.Identifier
	// Any data, depending on the channel. Typically this would be a sequence of fields using standard data types, but some unofficial channels have unusual formats. There is no length prefix that applies to all channel types, but the format specific to the channel may or may not include one or more length prefixes (e.g. for strings). The vanilla client enforces a length limit of 1048576 bytes on this data, but only if the channel type is unrecognized (which is the case for all login plugin messages with a completely vanilla client).
	Data ns.Varies
}

// S2CCookieRequestLogin represents "Cookie Request (login)".
//
// > Requests a cookie that was previously stored.
//
// https://minecraft.wiki/w/Java_Edition_protocol/Packets#Cookie_Request_(Login)
var S2CCookieRequestLogin = jp.NewPacket(jp.StateLogin, jp.S2C, 0x05)

type S2CCookieRequestLoginData struct {
	// The identifier of the cookie.
	Key ns.Identifier
}
