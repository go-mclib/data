//go:build ignore

package main

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"slices"
	"sort"
	"strings"
)

type CapturedPacket struct {
	Direction string `json:"direction"`
	State     string `json:"state"`
	PacketID  string `json:"packet_id"`
	WireData  string `json:"wire_data"`
}

type PacketSelector struct {
	Capture   string `json:"capture"`
	Direction string `json:"direction"`
	State     string `json:"state"`
	PacketID  string `json:"packet_id"`
	Index     int    `json:"index"`
}

type Manifest struct {
	Captures map[string]string         `json:"captures"`
	Packets  map[string]PacketSelector `json:"packets"`
}

func main() {
	manifestPath := "packet_manifest.json"
	if len(os.Args) > 1 {
		manifestPath = os.Args[1]
	}

	manifestDir := filepath.Dir(manifestPath)

	manifestData, err := os.ReadFile(manifestPath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "reading manifest: %v\n", err)
		os.Exit(1)
	}

	var manifest Manifest
	if err := json.Unmarshal(manifestData, &manifest); err != nil {
		fmt.Fprintf(os.Stderr, "parsing manifest: %v\n", err)
		os.Exit(1)
	}

	// load capture files
	captureData := make(map[string][]CapturedPacket)
	for name, path := range manifest.Captures {
		resolvedPath := filepath.Join(manifestDir, path)
		data, err := os.ReadFile(resolvedPath)
		if err != nil {
			fmt.Fprintf(os.Stderr, "reading capture %q (%s): %v\n", name, resolvedPath, err)
			os.Exit(1)
		}
		var packets []CapturedPacket
		if err := json.Unmarshal(data, &packets); err != nil {
			fmt.Fprintf(os.Stderr, "parsing capture %q: %v\n", name, err)
			os.Exit(1)
		}
		captureData[name] = packets
	}

	// resolve each manifest entry
	resolved := make(map[string]string) // name -> hex wire data
	for name, sel := range manifest.Packets {
		packets, ok := captureData[sel.Capture]
		if !ok {
			fmt.Fprintf(os.Stderr, "packet %q references unknown capture %q\n", name, sel.Capture)
			os.Exit(1)
		}

		matchIdx := 0
		found := false
		for _, pkt := range packets {
			if pkt.Direction == sel.Direction && pkt.State == sel.State && pkt.PacketID == sel.PacketID {
				if matchIdx == sel.Index {
					resolved[name] = pkt.WireData
					found = true
					break
				}
				matchIdx++
			}
		}
		if !found {
			fmt.Fprintf(os.Stderr, "packet %q: no match at index %d for %s %s %s in capture %q (found %d matches)\n",
				name, sel.Index, sel.Direction, sel.State, sel.PacketID, sel.Capture, matchIdx)
			os.Exit(1)
		}
	}

	// generate output
	names := slices.Sorted(func(yield func(string) bool) {
		for name := range resolved {
			if !yield(name) {
				return
			}
		}
	})

	// find max name length for alignment
	maxLen := 0
	for _, name := range names {
		if len(name) > maxLen {
			maxLen = len(name)
		}
	}

	var buf strings.Builder
	buf.WriteString("// Code generated by generate.go from packet captures; DO NOT EDIT.\n\n")
	buf.WriteString("package packets_test\n\n")
	buf.WriteString("// capturedHex maps packet test names to wire data as hex strings.\n")
	buf.WriteString("var capturedHex = map[string]string{\n")

	for _, name := range names {
		hexData := resolved[name]
		padding := strings.Repeat(" ", maxLen-len(name))
		buf.WriteString(fmt.Sprintf("\t%q: %s%q,\n", name, padding, hexData))
	}

	buf.WriteString("}\n")

	if err := os.WriteFile("packet_data_gen_test.go", []byte(buf.String()), 0644); err != nil {
		fmt.Fprintf(os.Stderr, "writing output: %v\n", err)
		os.Exit(1)
	}

	// print summary sorted by capture file
	captureNames := make([]string, 0, len(manifest.Captures))
	for name := range manifest.Captures {
		captureNames = append(captureNames, name)
	}
	sort.Strings(captureNames)

	fmt.Printf("generated packet_data_gen_test.go with %d packets from %d captures:\n", len(resolved), len(captureData))
	for _, capName := range captureNames {
		count := 0
		for _, sel := range manifest.Packets {
			if sel.Capture == capName {
				count++
			}
		}
		if count > 0 {
			fmt.Printf("  %s: %d packets\n", capName, count)
		}
	}
}
