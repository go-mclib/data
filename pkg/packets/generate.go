//go:build ignore

// generator for packet methods (ID, State, Bound) and the packet registry.
// scans existing packet source files for struct declarations and matches them
// to generated packet ID constants, then produces packets_gen.go and registry_gen.go.
//
// usage: go run generate.go

package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

// phase/bound info derived from file names
type fileInfo struct {
	state string // "Handshake", "Status", "Login", "Configuration", "Play"
	bound string // "C2S", "S2C"
}

// packet struct info
type packetInfo struct {
	structName string
	idConst    string
	state      string
	bound      string
}

// file name prefix â†’ state/bound mapping
var fileMapping = map[string]fileInfo{
	"c2s_handshaking":   {"Handshake", "C2S"},
	"c2s_status":        {"Status", "C2S"},
	"c2s_login":         {"Login", "C2S"},
	"c2s_configuration": {"Configuration", "C2S"},
	"c2s_play":          {"Play", "C2S"},
	"s2c_status":        {"Status", "S2C"},
	"s2c_login":         {"Login", "S2C"},
	"s2c_configuration": {"Configuration", "S2C"},
	"s2c_play":          {"Play", "S2C"},
}

// special cases where struct name doesn't match the ID constant convention
var idOverrides = map[string]string{
	"S2CLoginDisconnectLogin": "S2CLoginDisconnectID",
}

func main() {
	dir := "."
	if len(os.Args) > 1 {
		dir = os.Args[1]
	}

	packets := scanPacketStructs(dir)

	generatePacketMethods(packets, filepath.Join(dir, "packets_gen.go"))
	generateRegistry(packets, filepath.Join(dir, "registry_gen.go"))
}

// scanPacketStructs finds all packet struct types in the source files.
func scanPacketStructs(dir string) []packetInfo {
	var packets []packetInfo

	fset := token.NewFileSet()

	for filePrefix, info := range fileMapping {
		filename := filePrefix + ".go"
		path := filepath.Join(dir, filename)

		if _, err := os.Stat(path); os.IsNotExist(err) {
			continue
		}

		file, err := parser.ParseFile(fset, path, nil, 0)
		if err != nil {
			fmt.Fprintf(os.Stderr, "warning: could not parse %s: %v\n", path, err)
			continue
		}

		for _, decl := range file.Decls {
			genDecl, ok := decl.(*ast.GenDecl)
			if !ok || genDecl.Tok != token.TYPE {
				continue
			}
			for _, spec := range genDecl.Specs {
				typeSpec, ok := spec.(*ast.TypeSpec)
				if !ok {
					continue
				}
				// only struct types
				if _, ok := typeSpec.Type.(*ast.StructType); !ok {
					continue
				}

				name := typeSpec.Name.Name
				// skip helper structs (not starting with C2S or S2C)
				if !strings.HasPrefix(name, "C2S") && !strings.HasPrefix(name, "S2C") {
					continue
				}

				idConst := deriveIDConst(name)
				packets = append(packets, packetInfo{
					structName: name,
					idConst:    idConst,
					state:      info.state,
					bound:      info.bound,
				})
			}
		}
	}

	// sort for deterministic output
	sort.Slice(packets, func(i, j int) bool {
		if packets[i].state != packets[j].state {
			return packets[i].state < packets[j].state
		}
		if packets[i].bound != packets[j].bound {
			return packets[i].bound < packets[j].bound
		}
		return packets[i].structName < packets[j].structName
	})

	return packets
}

func deriveIDConst(structName string) string {
	if override, ok := idOverrides[structName]; ok {
		return override
	}
	return structName + "ID"
}

func generatePacketMethods(packets []packetInfo, outPath string) {
	var sb strings.Builder
	sb.WriteString(`// Code generated by generate.go; DO NOT EDIT.

package packets

import (
	"github.com/go-mclib/data/pkg/data/packet_ids"
	jp "github.com/go-mclib/protocol/java_protocol"
	ns "github.com/go-mclib/protocol/java_protocol/net_structures"
)

`)

	for _, p := range packets {
		sb.WriteString(fmt.Sprintf("func (p *%s) ID() ns.VarInt   { return ns.VarInt(packet_ids.%s) }\n", p.structName, p.idConst))
		sb.WriteString(fmt.Sprintf("func (p *%s) State() jp.State { return jp.State%s }\n", p.structName, p.state))
		sb.WriteString(fmt.Sprintf("func (p *%s) Bound() jp.Bound { return jp.%s }\n", p.structName, p.bound))
		sb.WriteString("\n")
	}

	writeFile(outPath, sb.String())
}

func generateRegistry(packets []packetInfo, outPath string) {
	// group by registry key
	type registryEntry struct {
		structName string
		idConst    string
	}
	registryMap := map[string][]registryEntry{}

	stateToPhase := map[string]string{
		"Handshake":     "handshake",
		"Status":        "status",
		"Login":         "login",
		"Configuration": "configuration",
		"Play":          "play",
	}

	for _, p := range packets {
		key := stateToPhase[p.state] + "_" + strings.ToLower(p.bound)
		registryMap[key] = append(registryMap[key], registryEntry{p.structName, p.idConst})
	}

	// sort keys
	var keys []string
	for k := range registryMap {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	var sb strings.Builder
	sb.WriteString(`// Code generated by generate.go; DO NOT EDIT.

package packets

import (
	"github.com/go-mclib/data/pkg/data/packet_ids"
	jp "github.com/go-mclib/protocol/java_protocol"
)

// PacketFactory creates a new packet instance.
type PacketFactory func() jp.Packet

// PacketRegistries maps phase+bound to a map of packet ID -> factory function.
// Keys are in format "phase_bound" like "configuration_c2s" or "play_s2c".
var PacketRegistries = map[string]map[int]PacketFactory{
`)

	for _, key := range keys {
		entries := registryMap[key]
		sort.Slice(entries, func(i, j int) bool {
			return entries[i].idConst < entries[j].idConst
		})

		sb.WriteString(fmt.Sprintf("\t%q: {\n", key))
		for _, e := range entries {
			sb.WriteString(fmt.Sprintf("\t\tint(packet_ids.%s): func() jp.Packet { return &%s{} },\n", e.idConst, e.structName))
		}
		sb.WriteString("\t},\n")
	}

	sb.WriteString("}\n")

	writeFile(outPath, sb.String())
}

func writeFile(path, content string) {
	if err := os.WriteFile(path, []byte(content), 0644); err != nil {
		fmt.Fprintf(os.Stderr, "error writing %s: %v\n", path, err)
		os.Exit(1)
	}
	fmt.Printf("wrote %s\n", path)
}
