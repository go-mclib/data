//go:build ignore

package main

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"unicode"
)

func main() {
	baseDir := filepath.Dir(os.Args[0])
	if len(os.Args) > 1 {
		baseDir = os.Args[1]
	}

	// load JSON data
	registries := loadJSON[map[string]RegistryJSON](filepath.Join(baseDir, "registries.json"))
	blocks := loadJSON[map[string]BlockJSON](filepath.Join(baseDir, "blocks.json"))
	items := loadJSON[map[string]ItemJSON](filepath.Join(baseDir, "items.json"))

	outDir := filepath.Dir(baseDir)

	// generate packages
	generateRegistries(registries, filepath.Join(outDir, "registries", "registries_gen.go"))
	generateBlocks(blocks, registries, filepath.Join(outDir, "blocks", "blocks_gen.go"))
	generateBlockStates(blocks, registries, filepath.Join(outDir, "blocks", "block_states_gen.go"))
	generateItems(items, registries, filepath.Join(outDir, "items", "items_gen.go"))
	generateComponentTypes(registries, filepath.Join(outDir, "items", "item_components_gen.go"))

	fmt.Println("generation complete")
}

// JSON structures

type RegistryJSON struct {
	ProtocolID int32                        `json:"protocol_id"`
	Default    string                       `json:"default,omitempty"`
	Entries    map[string]RegistryEntryJSON `json:"entries"`
}

type RegistryEntryJSON struct {
	ProtocolID int32 `json:"protocol_id"`
}

type BlockJSON struct {
	Definition BlockDefinitionJSON `json:"definition"`
	Properties map[string][]string `json:"properties"`
	States     []BlockStateJSON    `json:"states"`
}

type BlockDefinitionJSON struct {
	Type string `json:"type"`
}

type BlockStateJSON struct {
	ID         int32             `json:"id"`
	Default    bool              `json:"default,omitempty"`
	Properties map[string]string `json:"properties,omitempty"`
}

type ItemJSON struct {
	Components map[string]any `json:"components"`
}

// helpers

func loadJSON[T any](path string) T {
	data, err := os.ReadFile(path)
	if err != nil {
		panic(fmt.Sprintf("failed to read %s: %v", path, err))
	}
	var result T
	if err := json.Unmarshal(data, &result); err != nil {
		panic(fmt.Sprintf("failed to parse %s: %v", path, err))
	}
	return result
}

func writeFile(path, content string) {
	dir := filepath.Dir(path)
	if err := os.MkdirAll(dir, 0755); err != nil {
		panic(fmt.Sprintf("failed to create dir %s: %v", dir, err))
	}
	if err := os.WriteFile(path, []byte(content), 0644); err != nil {
		panic(fmt.Sprintf("failed to write %s: %v", path, err))
	}
	fmt.Printf("wrote %s\n", path)
}

func toGoName(id string) string {
	// minecraft:acacia_button -> AcaciaButton
	id = strings.TrimPrefix(id, "minecraft:")
	parts := strings.Split(id, "_")
	var result strings.Builder
	for _, part := range parts {
		if len(part) > 0 {
			// handle special cases like worldgen/biome_source
			subparts := strings.Split(part, "/")
			for _, sp := range subparts {
				if len(sp) > 0 {
					result.WriteString(strings.ToUpper(sp[:1]))
					result.WriteString(sp[1:])
				}
			}
		}
	}
	return result.String()
}

func toGoVarName(id string) string {
	name := toGoName(id)
	// handle names starting with numbers
	if len(name) > 0 && unicode.IsDigit(rune(name[0])) {
		name = "N" + name
	}
	return name
}

func sortedKeys[V any](m map[string]V) []string {
	keys := make([]string, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	return keys
}

// generators

func generateRegistries(registries map[string]RegistryJSON, outPath string) {
	var sb strings.Builder
	sb.WriteString("// Code generated by go generate; DO NOT EDIT.\n\n")
	sb.WriteString("package registries\n\n")

	// generate registry variables
	sb.WriteString("// Registry instances\nvar (\n")
	for _, name := range sortedKeys(registries) {
		reg := registries[name]
		goName := toGoVarName(name)
		sb.WriteString(fmt.Sprintf("\t%s = newRegistry(%d, %sEntries)\n", goName, reg.ProtocolID, strings.ToLower(goName[:1])+goName[1:]))
	}
	sb.WriteString(")\n\n")

	// generate entry maps
	for _, name := range sortedKeys(registries) {
		reg := registries[name]
		goName := toGoVarName(name)
		varName := strings.ToLower(goName[:1]) + goName[1:] + "Entries"

		sb.WriteString(fmt.Sprintf("var %s = map[string]int32{\n", varName))
		for _, entryName := range sortedKeys(reg.Entries) {
			entry := reg.Entries[entryName]
			sb.WriteString(fmt.Sprintf("\t%q: %d,\n", entryName, entry.ProtocolID))
		}
		sb.WriteString("}\n\n")
	}

	writeFile(outPath, sb.String())
}

func generateBlocks(blocks map[string]BlockJSON, registries map[string]RegistryJSON, outPath string) {
	blockRegistry := registries["minecraft:block"]

	var sb strings.Builder
	sb.WriteString("// Code generated by go generate; DO NOT EDIT.\n\n")
	sb.WriteString("package blocks\n\n")

	// block ID constants
	sb.WriteString("// Block protocol IDs\nconst (\n")
	for _, name := range sortedKeys(blockRegistry.Entries) {
		entry := blockRegistry.Entries[name]
		goName := toGoVarName(name)
		sb.WriteString(fmt.Sprintf("\t%s int32 = %d\n", goName, entry.ProtocolID))
	}
	sb.WriteString(")\n\n")

	// lookup maps
	sb.WriteString("var blockByName = map[string]int32{\n")
	for _, name := range sortedKeys(blockRegistry.Entries) {
		entry := blockRegistry.Entries[name]
		sb.WriteString(fmt.Sprintf("\t%q: %d,\n", name, entry.ProtocolID))
	}
	sb.WriteString("}\n\n")

	sb.WriteString("var blockByID = map[int32]string{\n")
	for _, name := range sortedKeys(blockRegistry.Entries) {
		entry := blockRegistry.Entries[name]
		sb.WriteString(fmt.Sprintf("\t%d: %q,\n", entry.ProtocolID, name))
	}
	sb.WriteString("}\n")

	writeFile(outPath, sb.String())
}

func generateBlockStates(blocks map[string]BlockJSON, registries map[string]RegistryJSON, outPath string) {
	blockRegistry := registries["minecraft:block"]
	// collect all unique properties and their values
	propertyValues := make(map[string][]string)
	for _, block := range blocks {
		for prop, values := range block.Properties {
			if existing, ok := propertyValues[prop]; ok {
				// merge values
				seen := make(map[string]bool)
				for _, v := range existing {
					seen[v] = true
				}
				for _, v := range values {
					if !seen[v] {
						propertyValues[prop] = append(propertyValues[prop], v)
						seen[v] = true
					}
				}
			} else {
				propertyValues[prop] = append([]string{}, values...)
			}
		}
	}

	var sb strings.Builder
	sb.WriteString("// Code generated by go generate; DO NOT EDIT.\n\n")
	sb.WriteString("package blocks\n\n")

	// property value indices lookup
	sb.WriteString("var propertyValueIndices = map[string]map[string]int{\n")
	for _, prop := range sortedKeys(propertyValues) {
		values := propertyValues[prop]
		sb.WriteString(fmt.Sprintf("\t%q: {\n", prop))
		for i, v := range values {
			sb.WriteString(fmt.Sprintf("\t\t%q: %d,\n", v, i))
		}
		sb.WriteString("\t},\n")
	}
	sb.WriteString("}\n\n")

	// generate block state data map
	sb.WriteString("var blockStates = map[int32]*blockStateData{\n")

	// we need block IDs - extract from states
	blockNames := sortedKeys(blocks)
	for _, blockName := range blockNames {
		block := blocks[blockName]
		if len(block.States) == 0 {
			continue
		}

		// find base and default state IDs
		baseID := block.States[0].ID
		defaultID := baseID
		for _, state := range block.States {
			if state.Default {
				defaultID = state.ID
				break
			}
		}

		// get property order from first state (or definition)
		var propOrder []string
		if len(block.Properties) > 0 {
			// need to determine order from states
			// the order in block.Properties map is not guaranteed
			// but states are ordered, so we can infer from state patterns
			propOrder = getPropertyOrder(block)
		}

		goName := toGoVarName(blockName)
		sb.WriteString(fmt.Sprintf("\t%s: {\n", goName))
		sb.WriteString(fmt.Sprintf("\t\tBaseID:    %d,\n", baseID))
		sb.WriteString(fmt.Sprintf("\t\tDefaultID: %d,\n", defaultID))

		if len(propOrder) > 0 {
			sb.WriteString("\t\tProperties: []blockProperty{\n")
			for _, prop := range propOrder {
				values := block.Properties[prop]
				sb.WriteString(fmt.Sprintf("\t\t\t{%q, []string{", prop))
				for i, v := range values {
					if i > 0 {
						sb.WriteString(", ")
					}
					sb.WriteString(fmt.Sprintf("%q", v))
				}
				sb.WriteString(fmt.Sprintf("}, %d},\n", len(values)))
			}
			sb.WriteString("\t\t},\n")
		}

		sb.WriteString("\t},\n")
	}
	sb.WriteString("}\n\n")

	// generate state range index for O(log n) lookup
	type stateRange struct {
		baseID  int32
		endID   int32
		blockID int32
	}
	var ranges []stateRange
	for _, blockName := range blockNames {
		block := blocks[blockName]
		if len(block.States) == 0 {
			continue
		}
		baseID := block.States[0].ID
		endID := block.States[len(block.States)-1].ID + 1
		blockID := blockRegistry.Entries[blockName].ProtocolID
		ranges = append(ranges, stateRange{baseID, endID, blockID})
	}
	// sort by baseID
	sort.Slice(ranges, func(i, j int) bool {
		return ranges[i].baseID < ranges[j].baseID
	})

	sb.WriteString("// stateRanges is sorted by BaseID for binary search.\n")
	sb.WriteString("var stateRanges = []stateRangeEntry{\n")
	for _, r := range ranges {
		sb.WriteString(fmt.Sprintf("\t{%d, %d, %d},\n", r.baseID, r.endID, r.blockID))
	}
	sb.WriteString("}\n")

	writeFile(outPath, sb.String())
}

// getPropertyOrder determines the order of properties for a block by analyzing its states.
func getPropertyOrder(block BlockJSON) []string {
	if len(block.States) < 2 || len(block.Properties) == 0 {
		return sortedKeys(block.Properties)
	}

	// the property that changes between consecutive states (with smaller index)
	// is the rightmost (fastest changing) property
	// we need to find the order by examining state transitions

	props := sortedKeys(block.Properties)
	if len(props) == 1 {
		return props
	}

	// calculate expected cardinality products to determine order
	// analyze which property changes at each step
	order := make([]string, 0, len(props))
	remaining := make(map[string]bool)
	for _, p := range props {
		remaining[p] = true
	}

	// the rightmost property changes every 1 state
	// the next one changes every (cardinality of rightmost) states
	// etc.

	stepSize := 1
	for len(remaining) > 0 {
		// find the property that changes at this step size
		for prop := range remaining {
			// check if this property changes at the expected interval
			if propertyChangesAtInterval(block, prop, stepSize) {
				order = append(order, prop)
				delete(remaining, prop)
				stepSize *= len(block.Properties[prop])
				break
			}
		}
		// safety check to avoid infinite loop
		if len(order) == 0 || (len(remaining) > 0 && stepSize > len(block.States)) {
			// fallback to sorted order
			return sortedKeys(block.Properties)
		}
	}

	// order is from rightmost to leftmost, need to reverse
	for i, j := 0, len(order)-1; i < j; i, j = i+1, j-1 {
		order[i], order[j] = order[j], order[i]
	}

	return order
}

func propertyChangesAtInterval(block BlockJSON, prop string, interval int) bool {
	if interval >= len(block.States) {
		return false
	}

	values := block.Properties[prop]
	if len(values) == 0 {
		return false
	}

	// check that the property cycles through its values at the given interval
	for i := 0; i < len(block.States); i++ {
		expectedValueIdx := (i / interval) % len(values)
		expectedValue := values[expectedValueIdx]
		actualValue := block.States[i].Properties[prop]
		if actualValue != expectedValue {
			return false
		}
	}
	return true
}

func generateItems(items map[string]ItemJSON, registries map[string]RegistryJSON, outPath string) {
	itemRegistry := registries["minecraft:item"]

	var sb strings.Builder
	sb.WriteString("// Code generated by go generate; DO NOT EDIT.\n\n")
	sb.WriteString("package items\n\n")

	// item ID constants
	sb.WriteString("// Item protocol IDs\nconst (\n")
	for _, name := range sortedKeys(itemRegistry.Entries) {
		entry := itemRegistry.Entries[name]
		goName := toGoVarName(name)
		sb.WriteString(fmt.Sprintf("\t%s int32 = %d\n", goName, entry.ProtocolID))
	}
	sb.WriteString(")\n\n")

	// lookup maps
	sb.WriteString("var itemByName = map[string]int32{\n")
	for _, name := range sortedKeys(itemRegistry.Entries) {
		entry := itemRegistry.Entries[name]
		sb.WriteString(fmt.Sprintf("\t%q: %d,\n", name, entry.ProtocolID))
	}
	sb.WriteString("}\n\n")

	sb.WriteString("var itemByID = map[int32]string{\n")
	for _, name := range sortedKeys(itemRegistry.Entries) {
		entry := itemRegistry.Entries[name]
		sb.WriteString(fmt.Sprintf("\t%d: %q,\n", entry.ProtocolID, name))
	}
	sb.WriteString("}\n\n")

	// generate default components data
	sb.WriteString("// defaultComponents maps item IDs to their default components.\n")
	sb.WriteString("var defaultComponents = map[int32]*Components{\n")

	for _, itemName := range sortedKeys(items) {
		item := items[itemName]
		itemID := itemRegistry.Entries[itemName].ProtocolID

		sb.WriteString(fmt.Sprintf("\t%d: { // %s\n", itemID, itemName))
		generateComponentsLiteral(&sb, item.Components, "\t\t")
		sb.WriteString("\t},\n")
	}
	sb.WriteString("}\n")

	writeFile(outPath, sb.String())
}

func generateComponentsLiteral(sb *strings.Builder, components map[string]any, indent string) {
	for _, key := range sortedKeys(components) {
		value := components[key]
		goField := componentKeyToGoField(key)
		if goField == "" {
			continue
		}

		switch key {
		case "minecraft:max_stack_size":
			if v, ok := value.(float64); ok {
				sb.WriteString(fmt.Sprintf("%sMaxStackSize: %d,\n", indent, int32(v)))
			}
		case "minecraft:damage":
			if v, ok := value.(float64); ok {
				sb.WriteString(fmt.Sprintf("%sDamage: %d,\n", indent, int32(v)))
			}
		case "minecraft:max_damage":
			if v, ok := value.(float64); ok {
				sb.WriteString(fmt.Sprintf("%sMaxDamage: %d,\n", indent, int32(v)))
			}
		case "minecraft:repair_cost":
			if v, ok := value.(float64); ok {
				sb.WriteString(fmt.Sprintf("%sRepairCost: %d,\n", indent, int32(v)))
			}
		case "minecraft:rarity":
			if v, ok := value.(string); ok {
				sb.WriteString(fmt.Sprintf("%sRarity: %q,\n", indent, v))
			}
		case "minecraft:break_sound":
			if v, ok := value.(string); ok {
				sb.WriteString(fmt.Sprintf("%sBreakSound: %q,\n", indent, v))
			}
		case "minecraft:item_model":
			if v, ok := value.(string); ok {
				sb.WriteString(fmt.Sprintf("%sItemModel: %q,\n", indent, v))
			}
		case "minecraft:instrument":
			if v, ok := value.(string); ok {
				sb.WriteString(fmt.Sprintf("%sInstrument: %q,\n", indent, v))
			}
		case "minecraft:jukebox_playable":
			if v, ok := value.(string); ok {
				sb.WriteString(fmt.Sprintf("%sJukeboxPlayable: %q,\n", indent, v))
			}
		case "minecraft:provides_banner_patterns":
			if v, ok := value.(string); ok {
				sb.WriteString(fmt.Sprintf("%sProvidesBannerPatterns: %q,\n", indent, v))
			}
		case "minecraft:provides_trim_material":
			if v, ok := value.(string); ok {
				sb.WriteString(fmt.Sprintf("%sProvidesTrimMaterial: %q,\n", indent, v))
			}
		case "minecraft:damage_type":
			if v, ok := value.(string); ok {
				sb.WriteString(fmt.Sprintf("%sDamageType: %q,\n", indent, v))
			}
		case "minecraft:food":
			if m, ok := value.(map[string]any); ok {
				sb.WriteString(fmt.Sprintf("%sFood: &Food{\n", indent))
				if n, ok := m["nutrition"].(float64); ok {
					sb.WriteString(fmt.Sprintf("%s\tNutrition: %d,\n", indent, int32(n)))
				}
				if s, ok := m["saturation"].(float64); ok {
					sb.WriteString(fmt.Sprintf("%s\tSaturation: %v,\n", indent, s))
				}
				sb.WriteString(fmt.Sprintf("%s},\n", indent))
			}
		case "minecraft:tool":
			if m, ok := value.(map[string]any); ok {
				sb.WriteString(fmt.Sprintf("%sTool: &Tool{\n", indent))
				if rules, ok := m["rules"].([]any); ok && len(rules) > 0 {
					sb.WriteString(fmt.Sprintf("%s\tRules: []ToolRule{\n", indent))
					for _, r := range rules {
						if rule, ok := r.(map[string]any); ok {
							sb.WriteString(fmt.Sprintf("%s\t\t{", indent))
							if b, ok := rule["blocks"].(string); ok {
								sb.WriteString(fmt.Sprintf("Blocks: %q, ", b))
							}
							if s, ok := rule["speed"].(float64); ok {
								sb.WriteString(fmt.Sprintf("Speed: %v, ", s))
							}
							if c, ok := rule["correct_for_drops"].(bool); ok {
								sb.WriteString(fmt.Sprintf("CorrectForDrops: %v", c))
							}
							sb.WriteString("},\n")
						}
					}
					sb.WriteString(fmt.Sprintf("%s\t},\n", indent))
				}
				sb.WriteString(fmt.Sprintf("%s},\n", indent))
			}
		case "minecraft:weapon":
			if m, ok := value.(map[string]any); ok {
				sb.WriteString(fmt.Sprintf("%sWeapon: &Weapon{\n", indent))
				if d, ok := m["disable_blocking_for_seconds"].(float64); ok {
					sb.WriteString(fmt.Sprintf("%s\tDisableBlockingForSeconds: %v,\n", indent, d))
				}
				if i, ok := m["item_damage_per_attack"].(float64); ok {
					sb.WriteString(fmt.Sprintf("%s\tItemDamagePerAttack: %d,\n", indent, int32(i)))
				}
				sb.WriteString(fmt.Sprintf("%s},\n", indent))
			}
		case "minecraft:enchantable":
			if m, ok := value.(map[string]any); ok {
				if v, ok := m["value"].(float64); ok {
					sb.WriteString(fmt.Sprintf("%sEnchantable: &Enchantable{Value: %d},\n", indent, int32(v)))
				}
			}
		case "minecraft:repairable":
			if m, ok := value.(map[string]any); ok {
				if items, ok := m["items"].(string); ok {
					sb.WriteString(fmt.Sprintf("%sRepairable: &Repairable{Items: %q},\n", indent, items))
				}
			}
		case "minecraft:item_name":
			if m, ok := value.(map[string]any); ok {
				if t, ok := m["translate"].(string); ok {
					sb.WriteString(fmt.Sprintf("%sItemName: &ItemNameComponent{Translate: %q},\n", indent, t))
				}
			}
		case "minecraft:fireworks":
			if m, ok := value.(map[string]any); ok {
				if fd, ok := m["flight_duration"].(float64); ok {
					sb.WriteString(fmt.Sprintf("%sFireworks: &Fireworks{FlightDuration: %d},\n", indent, int32(fd)))
				}
			}
		case "minecraft:use_cooldown":
			if m, ok := value.(map[string]any); ok {
				if s, ok := m["seconds"].(float64); ok {
					sb.WriteString(fmt.Sprintf("%sUseCooldown: &UseCooldown{Seconds: %v},\n", indent, s))
				}
			}
		case "minecraft:use_remainder":
			if m, ok := value.(map[string]any); ok {
				sb.WriteString(fmt.Sprintf("%sUseRemainder: &UseRemainder{\n", indent))
				if c, ok := m["count"].(float64); ok {
					sb.WriteString(fmt.Sprintf("%s\tCount: %d,\n", indent, int32(c)))
				}
				if id, ok := m["id"].(string); ok {
					sb.WriteString(fmt.Sprintf("%s\tID: %q,\n", indent, id))
				}
				sb.WriteString(fmt.Sprintf("%s},\n", indent))
			}
		case "minecraft:damage_resistant":
			if m, ok := value.(map[string]any); ok {
				if t, ok := m["types"].(string); ok {
					sb.WriteString(fmt.Sprintf("%sDamageResistant: &DamageResistant{Types: %q},\n", indent, t))
				}
			}
		case "minecraft:map_color":
			if v, ok := value.(float64); ok {
				sb.WriteString(fmt.Sprintf("%sMapColor: %d,\n", indent, int32(v)))
			}
		case "minecraft:ominous_bottle_amplifier":
			if v, ok := value.(float64); ok {
				sb.WriteString(fmt.Sprintf("%sOminousBottleAmplifier: %d,\n", indent, int32(v)))
			}
		case "minecraft:potion_duration_scale":
			if v, ok := value.(float64); ok {
				sb.WriteString(fmt.Sprintf("%sPotionDurationScale: %v,\n", indent, v))
			}
		case "minecraft:minimum_attack_charge":
			if v, ok := value.(float64); ok {
				sb.WriteString(fmt.Sprintf("%sMinimumAttackCharge: %v,\n", indent, v))
			}
		case "minecraft:glider":
			// marker component
			sb.WriteString(fmt.Sprintf("%sGlider: true,\n", indent))
		}
	}
}

func generateComponentTypes(registries map[string]RegistryJSON, outPath string) {
	componentRegistry := registries["minecraft:data_component_type"]

	var sb strings.Builder
	sb.WriteString("// Code generated by go generate; DO NOT EDIT.\n\n")
	sb.WriteString("package items\n\n")

	// component type constants
	sb.WriteString("// Component type protocol IDs from minecraft:data_component_type registry.\n")
	sb.WriteString("// https://minecraft.wiki/w/Java_Edition_protocol/Slot_data#Structured_components\n")
	sb.WriteString("const (\n")

	// find max ID for the constant
	var maxID int32
	for _, name := range sortedKeys(componentRegistry.Entries) {
		entry := componentRegistry.Entries[name]
		goName := "Component" + toGoVarName(name)
		// use untyped constants so they work with VarInt comparisons
		sb.WriteString(fmt.Sprintf("\t%s = %d\n", goName, entry.ProtocolID))
		if entry.ProtocolID > maxID {
			maxID = entry.ProtocolID
		}
	}
	sb.WriteString(fmt.Sprintf("\n\tMaxComponentID = %d\n", maxID))
	sb.WriteString(")\n")

	writeFile(outPath, sb.String())
}

func componentKeyToGoField(key string) string {
	switch key {
	case "minecraft:max_stack_size":
		return "MaxStackSize"
	case "minecraft:damage":
		return "Damage"
	case "minecraft:max_damage":
		return "MaxDamage"
	case "minecraft:repair_cost":
		return "RepairCost"
	case "minecraft:rarity":
		return "Rarity"
	case "minecraft:break_sound":
		return "BreakSound"
	case "minecraft:item_model":
		return "ItemModel"
	case "minecraft:food":
		return "Food"
	case "minecraft:tool":
		return "Tool"
	case "minecraft:weapon":
		return "Weapon"
	case "minecraft:enchantable":
		return "Enchantable"
	case "minecraft:repairable":
		return "Repairable"
	case "minecraft:item_name":
		return "ItemName"
	case "minecraft:instrument":
		return "Instrument"
	case "minecraft:jukebox_playable":
		return "JukeboxPlayable"
	case "minecraft:provides_banner_patterns":
		return "ProvidesBannerPatterns"
	case "minecraft:provides_trim_material":
		return "ProvidesTrimMaterial"
	case "minecraft:damage_type":
		return "DamageType"
	case "minecraft:fireworks":
		return "Fireworks"
	case "minecraft:use_cooldown":
		return "UseCooldown"
	case "minecraft:use_remainder":
		return "UseRemainder"
	case "minecraft:damage_resistant":
		return "DamageResistant"
	case "minecraft:map_color":
		return "MapColor"
	case "minecraft:ominous_bottle_amplifier":
		return "OminousBottleAmplifier"
	case "minecraft:potion_duration_scale":
		return "PotionDurationScale"
	case "minecraft:minimum_attack_charge":
		return "MinimumAttackCharge"
	case "minecraft:glider":
		return "Glider"
	// skip these for now as they're empty or complex
	case "minecraft:enchantments",
		"minecraft:lore",
		"minecraft:attribute_modifiers",
		"minecraft:swing_animation",
		"minecraft:tooltip_display",
		"minecraft:use_effects",
		"minecraft:consumable",
		"minecraft:container",
		"minecraft:stored_enchantments",
		"minecraft:potion_contents",
		"minecraft:bundle_contents",
		"minecraft:charged_projectiles",
		"minecraft:debug_stick_state",
		"minecraft:entity_data",
		"minecraft:bucket_entity_data",
		"minecraft:block_entity_data",
		"minecraft:block_state",
		"minecraft:bees",
		"minecraft:lock",
		"minecraft:container_loot",
		"minecraft:pot_decorations",
		"minecraft:writable_book_content",
		"minecraft:written_book_content",
		"minecraft:trim",
		"minecraft:suspicious_stew_effects",
		"minecraft:banner_patterns",
		"minecraft:base_color",
		"minecraft:profile",
		"minecraft:note_block_sound",
		"minecraft:lodestone_tracker",
		"minecraft:firework_explosion",
		"minecraft:map_decorations",
		"minecraft:map_id",
		"minecraft:map_post_processing",
		"minecraft:recipes",
		"minecraft:dyed_color",
		"minecraft:creative_slot_lock",
		"minecraft:intangible_projectile",
		"minecraft:custom_data",
		"minecraft:custom_model_data",
		"minecraft:custom_name",
		"minecraft:enchantment_glint_override",
		"minecraft:death_protection",
		"minecraft:blocks_attacks",
		"minecraft:kinetic_weapon",
		"minecraft:piercing_weapon",
		"minecraft:attack_range",
		"minecraft:equippable",
		"minecraft:unbreakable",
		"minecraft:can_break",
		"minecraft:can_place_on":
		return ""
	default:
		return ""
	}
}
